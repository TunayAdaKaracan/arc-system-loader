picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0iMjAyMy0xMC0xOSAxNjo1MDowNyIsaWNv
bj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAw
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQw
NzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDA3MDcwNzA3MGQwZDBk
MGQwZDBkMGQwNzAxMDEwNzBkMDcwNzA3MDcwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwNzBkMDcw
NzA3MDcwNzBkMGQwZDA3MDcwMTAxMDcwZDA3MDcwNzA3MGQwZDBkMGQwNzBkMDcwNzAxMDEwNzBk
MDcwNzBkMGQwNzBkMGQwZDA3MGQwNzA3MDEwMTA3MGQwNzA3MGQwZDBkMDcwZDBkMGQwZDBkMDcw
MTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBk
MGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYw
NjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVkPSIyMDI0LTA3LTEyIDE5OjQzOjQzIixu
b3Rlcz0iKGMpIExleGFsb2ZmbGUgR2FtZXMgTExQIixyZXZpc2lvbj0wLHJ1bnRpbWU9Nix0aXRs
ZT0iUGljb3Ryb24gVHJhY2tlciIsdmVyc2lvbj0iMC4xZiIsd29ya3NwYWNlcz17e2xvY2F0aW9u
PSJtYWluLmx1YSMzMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ3VpLmx1YSM0MjMi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imluc3QubHVhIzQ5MCIsd29ya3NwYWNlX2lu
ZGV4PTF9LHtsb2NhdGlvbj0iZW52Lmx1YSMxMjEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249InRyYWNrLmx1YSMxMzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImRlYnVnLmx1
YSMyMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idXBkYXRlLmx1YSM3MiIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZGF0YS5sdWEjNDIiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dbHo0AAQAAAADAAAAMG5p
bA==
:: gfx/
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA5IDAyOjM2OjAxIixtb2RpZmllZD0iMjAyNC0w
Ny0xMiAxOTo0Mzo0MyIscmV2aXNpb249MF1dbHo0AAQAAAADAAAAMG5pbA==
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTMwLTIyIDA3OjMwOjA0Iixtb2RpZmllZD0iMjAyNC0w
My0zMCAyMDozNDoyMiIscmV2aXNpb249Nzk0NCxzdG9yZWQ9IjIwMjMtMzYtMjkgMDQ6MzY6NDAi
XV1sejQAkQUAAFQ2AADxCntbMF09e2JtcD1weHUAQyAFBQQgBzAHAEcGAPEBLGZsYWdzPTAscGFu
X3g9NggA2nk9LTQsem9vbT04fSw7AFcnABcABwQAHydBAB2-BwA3MAcgBzA3AAc7AB0wEAcgfwBP
JyAHQDsAH38wB4AHMAcQOQAaWxAQBPDwMgATMDIAHzAxAAVwERcQFyAnQOQA8AMXMCcQFxAn8AQH
AAcQFxAHUCfDAP8AUAcAFyAn8AQn4AfgB-AsYAAZICAQgQEAVAARAFMAMgAHIAoA8QMHIAcgFwAn
EAcQJyAHACcAJxAoASAAFxAAP-D-ksUAHR-wMQD-D1IEBAQAF9cBPwAXADoAGbEFBQQAJwAHIBcg
F6wBDzwAHD_gJ6AyABx-UCcQJxAnUDYAHEBgByAHXAIObgMPOgANL-AJMQCs-wMICASwDxBQLjAu
MA4ADkAe8AVvABwBOQExQEdACAAPPAAdMTAHMNMDA2QFD0AAHSEgFw4EAEcAD3oAHSAgZ3AAADkE
HxCRAXtUyGQE8P8BAPAQcVHwsXHwr5HwAyHwlsHwAUHwlOHwAEHwPzHwQHEQUQsAgj5R8D5xMFHg
CgAgYUAKAMA9YfAhIfAJUXBRwFENAFEgQfAHYQ0A8Ao8YfAhQfAGYZBBwEHwJyHwA2HwIFHwBlGg
EABRJkHwAXEQACJBsBAAIOCBDwCwB0GwQbBR8CZB0JEPADAIIcAPACAlUQ8AsUHwGUGwQfAmUcCh
DQCAUaBB8CVhwJFnAJAZUZBR8CVhsKE2ACAaQQ0AJFHADQAANAAgsLE0ABobDQAQgDQAZKBRAEHw
IQ8AIFGwDwAAOAARUQ8ANKBREA8AADoAcqBRAFHwH1FJAEQlYZBhDwAALQBHYZBREDwAQWGAUSBa
AAE8ACQlcQ8AIBlRPABHcXBRMA8AIGGADwBCGSFQIdkAtyRxcFFAQfAYQfAhDwDwFxdR8CBRsEHw
CYHwAnFgUVBB8BZh8B-xEsCx8AFxUGFQQdAhQIFQEwDwBxSQ4eCBUFFgQcDxAwCR8CDxFIDxAOAk
AMBRsPEO8CHxFHDxAdAiAPASUaDxDvAi8RNwgTBB0IFAUXBBsPEN8CJR0FHwAmEwYcCREwAQoBMA
8BBh0EHwA0EwgcCRMFGAQZBhEPEB8CVh4EHwAlEQkcChFQBhgHFAofAoLgLVAvECwKEgUZBBYIGg
URQAUAHAUQBBFgBwMLGgUfAnUWkCQALR8AAWAJJBoEEQ0aBB8CgWAMLB8ABREEEQUaBBANEsAHIC
QfACkfADFgCh8QSgUfAHIfAMYRgAwHHwBFEgQQBRsPEEkEgC8QbwCmHwA1HwAWGwMUBRILHAoSBB
YIEYAHBR8ARR8AJxcQGwMKHgYVBBQJHwB1EYAPAIBUHwA4FgUSBRMKHwAEFgQSCx8AZh8Am2AsDw
A-EFEGEwkfAN8QMuACAJYRUAYATxAxBhQBUAEAEnAPMECVHwCEHwBfEBIFFQkfAO0fALQRcAMAbR
MH8AcRCR8A8h8AlUAPEnCKFQIYBR8BNh8Cxx8ApB8JFh8AtR8JBR8AxR8JEx8A5R8LJR8LNR8LJh
8LJx8LCB8LBx8LFhFQA6MfD-AQAfZfcDCx4yKAQP9wceDzEA-3UTMj4IkwAHUAcQJwAnQFsGIPAF
CQCDFxAHcAcgBxAXAE8AJ-BDYQAMDxoCMA8xAP--mGMHBwQgFzA2DgQEAAAQAC9AF5oJDCwxNkkA
8QAOEB0ADgAODQANDgAdDgAPACANEAoAEiAVAAESAA9WAB1jkAdQFxBXoQAvB5A-AB0igAfUAH8A
VxAXUAegPwAdM3BHEAIAH3A7AA0PugEeDzEA----------------------------------------
---------zFQbT04fX0=
:: map/
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTA5IDAyOjM2OjAxIixtb2RpZmllZD0iMjAyNC0w
Ny0xMiAxOTo0Mzo0MyIscmV2aXNpb249MF1dbHo0AAQAAAADAAAAMG5pbA==
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTMwLTIyIDA3OjMwOjA0IixyZXZpc2lvbj00MjkyLHN0
b3JlZD0iMjAyMy0zNi0yOSAwNDozNjo0MCJdXXtsYXllcj17WzBdPXtibXA9dXNlcmRhdGEoImkx
NiIsMTYsMTYsIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAiKSxwYW5feD0wLHBhbl95PTAsc2NhbGU9MSx0aWxlX2g9MTYsdGlsZV93PTE2fX19
:: amp.lua
--[[pod_format="raw",created="2023-29-17 13:29:48",revision=257,stored="2023-27-19 23:27:17"]]
-- amp filter










































































:: data.lua
--[[pod_format="raw",created="2023-10-24 00:36:58",modified="2024-04-28 08:42:00",revision=7058,stored="2023-36-29 04:36:40"]]
function init_data()

	-- use 256k from 0x30000
	-- gives 399 SFX and managemable size for undo state comparisons
	-- if change this need, to adjust undo stack size and loader/saver
	
	memset(0x30000, 0, 0x40000)
	

	-- index (0x30000)
	
	-- first 3 values are almost metadata only -- not currently
	-- acted on anywhere. perhaps useful in future for deciding
	-- scope of copy/paste, and gui cues, but can be calculated
	-- from content.
	
	poke2(0x30000,
		64,  -- num_instruments
		512, -- num_tracks (64 patterns * 8 channels for default indexing)
		64,  -- num_patterns
		-- flags: 0x1 use default track indexing (base+0x20000, increments of 328 bytes)
		0x1
	)
	poke4(0x30010,
		0x10000, -- insts_addr      (I32)    relative address of instruments
		0x20000, -- tracks_addr     (I32)    relative address of track index
		0,       -- patterns_addr   (I32)    relative address of pattern data
		0        -- unused          (I32)    should be 0
	)
	poke2(0x30020,
		0,  -- tick len (0 for default -- custom vals not supported yet)
		64, -- default track length
		16 -- default track spd
	)
	
	-- default track speed (+3 unused)
	poke(0x30026, 16, 0, 0, 0) 
	
	-- pattern data: first 16 patterns
	-- want to keep default sfx file quite tiny
	-- .. should be ok to save a whole .sfx for just one inst / experiment
	-- later: interface to generate more default patterns
	
	for pp = 0,1 do
		local addr = 0x30100 + pp * 20
		for i = 0, 7 do
			poke(addr+i, pp*8 + i)
		end
		poke(addr+8, 0x0)  -- flow flags
		poke(addr+9, 0xff) -- channel mask
		poke(addr+10, 0,0) -- length (I16)
		
	end
	
	
	----------------------------------------------------------------------------
	-- single instrument at 0x40000 (instrument 0)
	
	-- node 0: root
	poke(0x40000 + (0 * 32), -- instrument 10node 0
	
			0,    -- parent (0x7)  op (0xf0)
			1,    -- kind (0x0f): 1 root  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2|0x4,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x1,0,0,0,     -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			0x1,0,0,0,     -- bend: none
			-- following shouldn't be in root
			0x0,0,0,0,     -- wave: use wave 0 
			0x0,0,0,0      -- phase 
	)
	
	
	-- node 1: sine
	poke(0x40000 + (1 * 32), -- instrument 0, node 1
	
			0,    -- parent (0x7)  op (0xf0)
			2,    -- kind (0x0f): 2 osc  kind_p (0xf0): 0  -- wavetable_index
			0,    -- flags
			0,    -- unused extra
				
			-- MVALs:  kind/flags,  val0, val1, envelope_index
			
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:   add. center
			0x21,0,0,0,    -- tune: +0 -- 0,48,0,0 absolute for middle c (c4) 261.6 Hz
			               -- tune is quantized to semitones with 0x20
			0x1,0,0,0,     -- bend: none
			0x0,0x40,0,0,  -- wave: triangle
			0x0,0,0,0      -- phase 
	)
	
	

	-- wavetable
	for i=0,7 do
	poke(0x40000 + 0x1e0,
		0x00, -- address (low)  in 256 byte increments
		0xf8, -- address (high) in 64k increments
		0x0a, -- samples (1 << n) 1024
		0xff,  -- wt_height 256(0); wave mval points at one of the entries
		
		-- to do: update (is garbage now?)
		0x80,
		0xf7,
		0x0d, -- samples (1 << n) 8192
		0x01
	)
	end

	-- envelope 0 inst 1
	
	poke(0x40000 + 0x100,
		0,0,0,0, 0,0,0,0,
		0,40,255,0 -- adsr
	)
	
	-- copy default instrument to 1..31
	for i=1,31 do
		memcpy(0x40000 + 0x200*i, 0x40000, 0x200)
	end
	
	--------------------------------------------------
	-- Track Data  0x50000
	--------------------------------------------------
	
	-- Default track size is 5 * 64 rows + 8 = 328 bytes
	
	-- header (8)
	local addr = 0x50000
	poke2(addr, 64) -- len
	poke(addr+2,16) -- spd
	poke(addr+3,0)  -- loop0
	poke(addr+4,0)  -- loop1
	poke(addr+5,0)  -- delay
	poke(addr+6,0)  -- flags (0x1 mute)
	poke(addr+7,0)  -- unused
	
	-- pitch, inst, vol: not set (0xff)
	memset(addr+8, 0xff, 64*3)
	
	-- copy to other tracks: 128k worth
	-- ** only first 399 are saved / undoable (0x20000\328) **
	
	for i=1,398 do
		memcpy(0x50000 + i*328, 0x50000, 328)
	end
	

end






:: debug.lua
--[[pod_format="raw",created="2024-03-13 08:36:45",modified="2024-04-28 08:42:00",revision=544]]

function draw_mudo_state(x,y)
	rectfill(x,y,x+99,y+60,0)
	
	for i=0,7 do
		local sx = x + 2
		local sy = y + i * 6	
		
		-- chan->playing_track_index
		print("\14"..stat(400+i,12), sx, sy, 7)
		
		-- chan->inst		
		print("\14"..stat(400+i,1 ), sx+30, sy, 7)
		
		-- chan->track_row
		print("\14"..stat(400+i,9 ), sx+60, sy, 13)
		
	end
	print(string.format("cpu:%3.3f", stat(1)),x,y+52,13)
	print(tostr(something_is_playing),x+50,y+52,14)
end

:: env.lua
--[[pod_format="raw",created="2023-10-08 03:32:58",modified="2024-04-28 08:42:00",revision=2302,stored="2023-36-29 04:36:40"]]

-- flags: lerp, random start position
-- used by DATA envelope
function create_env_flag_toggle(addr,flag,label,x,y)
	local el = {
		addr = addr, flag = flag, label=label,
		x = x, y = y, width = 18+#label*4, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & self.flag
		--clip()
		--rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 
		--	(val>0 and 7 or 13))
		local str=val>0 and "[/] " or "[ ] "
		if (self.flag == 0x10) str = "" -- EF_ADVANCED_OPTS doesn't have checkbox
		print(str..self.label,2,1+yy,13)
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr)
		val ^^= self.flag
		poke(self.addr, val)
		refresh_gui = true
	end
	
	return el
end


env_type_str = {[0]=
	"adsr",
	"lfo",
	"data",
}



function create_env_type_toggle(addr,x,y)
	local el = { 
		addr = addr,
		x = x, y = y, width = 20, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & 0xf
		clip()
		--pal(7,1)
		rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 6)
		--spr(val,1,1+yy)
		print(env_type_str[val],2,1+yy,1)
		--pal()
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr)
		val = (val + 1) % 3
		poke(self.addr, (peek(self.addr) & 0xf0) | (val & 0x0f))
		refresh_gui = true
	end
	
	return el
end

function create_env_plug(index, x, y)
	local el = {
		x=x,y=y,width=7,height=7,index=index,
		click=checkpoint
	}
	function el:draw(msg)
		circfill(3,3,2,13)
		circ(3,3,2,1)
	end
	function el:release(msg)
		local sx=self.sx + msg.mx
		local sy=self.sy + msg.my
		
		local el2 = gui:el_at_xy(sx,sy)
		if (el2.drop_env_plug) el2:drop_env_plug{index=self.index}
		
	end
	
	return el
end


--[[
	edit an 8-bit value in memory
]]
function create_tiny_knob(label,addr,x,y,has_knob)
	local el={
		x=x,y=y,
		width=15,height=has_knob and 24 or 14,
		label=label,addr=addr,
		dval=0,
		--cursor="grab" -- to do: dial spinning cursor that disappears
	}
	
	function el:draw()
		local val=peek(self.addr)
		if (has_knob) then
			circ(7,5,5,13)
			local aa=.7-val*.9/255.0
			line(7.5+cos(aa),5.5+sin(aa),7.5+cos(aa)*4,5.5+sin(aa)*4,7)
		end
		
		clip()
		
		-- 
		local yy=has_knob and 14 or 2
		rectfill(0,yy,14,yy+6,0)
		local str=tostr(val)
		print(str,14-#str*4,yy+1,3)
		
		print(self.label,9-#self.label*2,yy+10,13)

	end
	
	-- turn mouse locking on while dragging
	function el:click(msg)
		mouselock(0x4|0x8, 0.5, 0.05) -- 0x4 lock 0x8 auto-release, event speed, move speed 
	end
	
	function el:drag(msg)
		local val=peek(self.addr)
		-- accumulate change at 0.5 per pixel
		el.dval += (msg.dx - msg.dy) * 0.5
		if (el.dval <= -1) then
			val -= flr(-el.dval)
			el.dval += flr(-el.dval)
		end
		if (el.dval >= 1) then
			val += flr(el.dval)
			el.dval %= 1
		end
		val = mid(0,val,255)
		poke(self.addr, val)
	end
	
--[[
	-- annoying
	-- doesn't mix with drag control
	-- pico-8 actually suffers from the same problem!
	-- (just not pronounced because easy to keep the cursor still,
	--  and hard to drag -1 or +1 while starting and ending inside el)
	
	function el:tap(msg)
		local val = peek(self.addr)
		local mag = key("ctrl") and 8 or 1
		val += msg.last_mb == 2 and -mag or mag
		poke(self.addr,mid(0,val,255))
	end
]]
	
	return el
end


function create_data_env_editor(addr, x, y, width, height)
	local el={
		addr=addr,
		x=x,y=y,width=width,height=height
	}
	function el:draw()
		rectfill(0,0,self.width-1,self.height-1,0)
		local ww=width\16
		local hh=self.height
		local loop0 = @(addr+3)
		local loop1 = @(addr+4)
		
		-- show loop points
		fillp(0x5a5a)
		col = loop0 < loop1 and 6 or 5
		line(loop0*ww-1,0, loop0*ww-1,self.height,col)
		line(loop1*ww-1,0, loop1*ww-1,self.height,col)
		fillp()
		
		-- show data
		for i=0,15 do
			local sx = i*ww
			local val = peek(self.addr+i+8)
			local col = i >= loop0 and i < loop1 and 13 or 12
			rectfill(sx,hh,sx+ww-2,hh-val*hh/255,col)
			rectfill(sx,hh-val*hh/255,sx+ww-2,hh-val*hh/255,28)
		end
		
	end
	
	function el:drag(msg)
		local ww=width\16
		local hh=self.height
		local xx=mid(0,msg.mx\ww,15)
		local yy=(msg.my) * 255 / self.height
		poke(self.addr+xx+8,mid(0,255-yy,255))
	end
	
	return el
end


function create_env_editor(index, addr, label, x, y, width)

	local height = 46
	if (@addr == 1) height = 54 -- lfo
	if (@addr == 2) height = 86 -- data
	
	local height0 = height
	
	if (peek(addr+1)&0x10>0 and @addr<2) then
		height += 28
	end
	
	local pane = gui:attach(create_pane("\fh"..label, x, y, width, height, 0x0701))
	pane.index = index
	
	-- don't need plug! just drag whole pane
	--pane:attach(create_env_plug(index,2,1))
	
	
	pane:attach(create_env_type_toggle(addr,44,1))
	
	
	-- adsr
	if (peek(addr) == 0) then
		-- no labels: it's in the name of the envelope!
		--local knob_name={[0]="atk","dcy","sus","rel"}
		for i=0,3 do
			pane:attach(create_tiny_knob("",addr+8+i,2+i*20,16,true))
		end
	end
	
	-- lfo
	if (peek(addr) == 1) then
		pane:attach(create_tiny_knob("freq",addr+12+0,8,16,true))
		--pane:attach(create_tiny_knob("func",addr+13+0,31,28,false))
		pane:attach(create_tiny_knob("phase",addr+14+0,54,16,true))
		
	end
	
	-- data footer thing
	if (peek(addr) == 2 or peek(addr+1)&0x10>0) then
		
		if (peek(addr) != 2) then
			-- non-data only needs the start at rnd(t0), so can have more verbose version
			--pane:attach(create_env_flag_toggle(addr+1,0x8,"rnd start",20,pane.height-27))
			pane:attach(create_env_flag_toggle(addr+1,0x8,"rnd",46,pane.height-27))
		end
		
		-- starting from env_def[1]  -- env_def[0] is flags
		local knob_name={[0]="spd","lp0","lp1","t0"}
		for i=0,3 do
			pane:attach(create_tiny_knob(knob_name[i],addr+2+i,2+i*20,
				pane.height-20,false))
		end
		
	end
	
	-- data editor
	if (peek(addr) == 2) then
		pane:attach(create_data_env_editor(addr,0,9,80,48))
	
		-- lerp, rnd_start
		pane:attach(create_env_flag_toggle(addr+1,0x1,"lerp",2,pane.height-27))
		pane:attach(create_env_flag_toggle(addr+1,0x8,"rnd",46,pane.height-27))
		
	end
	
	-- show advanced options / ... button
	if (peek(addr) < 2) then
		local str="\f5\^:0000001500000000" -- ...
		if (peek(addr+1)&0x10>0) str="\f5\^:0000040e1f000000" -- up arrow
		pane:attach(create_env_flag_toggle(addr+1,0x10,str,width/2-6,height0-8))
	end
	
	
	-- can drag and drop anywhere on pane
	function pane:release(msg)
		local sx=self.sx + msg.mx
		local sy=self.sy + msg.my
		
		local el2 = gui:el_at_xy(sx,sy)
		if (el2 and el2.drop_env_plug) el2:drop_env_plug{index=self.index}
		
	end
	
	return pane
end









































































:: gui.lua
--[[pod_format="raw",created="2023-10-22 07:32:11",modified="2024-04-28 08:42:00",revision=9103,stored="2023-36-29 04:36:40"]]

function create_pane(title, x, y, w, h, col)

	if (not col) col = 0x0705 -- default back
	
	local el={
		title=title,
		x=x,y=y,width=w,height=h,
		col=col
	}
	
	function el:draw()
	
		local col = (self.col >> 0) & 0xff
		local hcol = (self.col >> 8) & 0xff
		
		rectfill(1,0,self.width-2,0,hcol)
		rectfill(0,1,self.width,8,hcol)
		rectfill(0,9,self.width-1,self.height-2,col)
		rectfill(1,self.height-1,self.width-2,self.height-1,col)
		
		--print(title,14,2,1) -- assume some kind of icon to the left
		print(title,6,2,1) -- assume some kind of icon to the left
		
	end
	return el
end

function create_instrument_chooser(el)
	-- instrument chooser
	local container = el:attach{
		x=2,y=10,width=el.width-2,height=el.height-11,
		draw=function(self)
			-- some parent turned clipping off; can turn back on here
			clip(self.sx,self.sy,self.width,self.height)
		end
	}
	local contents = container:attach{
		x=0,y=0,width=86,height=256,
		draw=function(self)
			for i=0,31 do
				if (ci == i) rectfill(0,i*8,self.width-1,i*8+6,16)
				print(string.format("%02i inst ",i),2,1 + i*8,6)
			end
		end,
		click=function(self,msg)
			ci = msg.my\8
			if (key"ctrl") mode = "instrument"
			refresh_gui = true
		end
	}
	container:attach_scrollbars()
	
	-- center (don't need to store scrolling position when gui refreshed)
	contents.y = -ci * 8 + 30

	-- clamp
	contents.y = mid(0, contents.y, - (contents.height - container.height))
end

function create_track_chooser(el)

	local container = el:attach{
		x=2,y=10,width=el.width-2,height=el.height-11,
		draw=function(self)
			-- some parent turned clipping off; can turn back on here
			clip(self.sx,self.sy,self.width,self.height)
		end
	}
	local contents = container:attach{
		x=0,y=0,width=86,height=32*16,
		draw=function(self)
			for i=0,127 do
				local x = 0 + (i % 4) * 19
				local y = 2 + (i \ 4) * 16
				rectfill(x,y,x+16,y+12, ct == i and 29 or 18)
				print(string.format("%02i",i),x+5,y+2,1)
				if (playing_row(i)) then
					for j=0,2 do
						--circfill(x+4+j*4,y+10,.8+cos(-j*.3+t()*2), 7)
						rectfill(x+3+j*4,y+11,x+5+j*4,y+11-max(cos(-j*.3+t()*3))*2,7)
					end
				end
			end
		end,
		
		tap=function(self, msg)
			checkpoint()
			ct = mid(0, msg.mx \ 20, 3) + ((msg.my-2) \ 16) * 4
			mode = "track"
			refresh_gui = true
		end
	}
	container:attach_scrollbars()
	
	contents.y = -(ct\4) * 12 + 20

	-- clamp
	contents.y = mid(0, contents.y, - (contents.height - container.height))
	
end

function create_pattern_chooser(el)

	local container = el:attach{
		x=2,y=10,width=el.width-2,height=el.height-11,
		draw=function(self)
			-- some parent turned clipping off; can turn back on here
			clip(self.sx,self.sy,self.width,self.height)
		end
	}
	local contents = container:attach{
		x=0,y=0,width=86,height=200,
		draw=function(self)
			local playing_pattern = stat(466)
			for i=0,63 do
				local x = 0 + (i % 4) * 19
				local y = 2 + (i \ 4) * 12
				rectfill(x,y,x+16,y+8, cp == i and 14 or 1)
				rect(x,y,x+16,y+8, cp == i and 14 or 13)
				
				print(string.format("%02i",i),x+5,y+2, cp == i and 1 or 18)
				
				if (playing_pattern == i) then
					for j=0,2 do
						rectfill(x+3+j*4,y+9,x+5+j*4,y+9-max(cos(-j*.3+t()*3))*2,7)
					end
				end
				
			end
		end,
		
		tap=function(self, msg)
			checkpoint()
			cp = mid(0, msg.mx \ 20, 3) + ((msg.my-2) \ 12) * 4
			mode = "pattern"
			refresh_gui = true
		end
	}
	container:attach_scrollbars()
	
	contents.y = -(cp\4) * 12 + 20

	-- clamp
	contents.y = mid(0, contents.y, - (contents.height - container.height))
	
end

function create_volume_chooser(x, y)
	local el ={
		x = x, y = y, width=42, height = 7,
		cursor = "pointer"
	}
	function el:draw()
		clip()
		print("\014vol",-15,1,1)
		for i=0,6 do
			local sx = i * 5
			rectfill(sx,0,sx+4,6, (i+1)*0x8 == cvol and 6 or 13)
			--print("\014"..(i+1),sx+1,1,13)
		end
	end
	function el:drag(msg)
		cvol = mid(1,(1+(msg.mx\5)),7)*0x8
	end
	
	return el
end

 
function create_octave_chooser(x, y)
	local el ={
		x = x, y = y, width=42, height = 7,
		cursor = "pointer"
	}
	function el:draw()
		clip()
		print("\014oct",-15,1,1)
		for i=0,6 do
			local sx = i * 5
			rectfill(sx,0,sx+4,6,i+1 == coct and 6 or 13)
			print("\014"..(i+1),sx+1,1,i+1 == coct and 13 or 13)
		end
	end
	function el:drag(msg)
		coct = mid(1,1+(msg.mx\5),7)
	end
	
	return el
end


function generate_gui_track()

	local xx = 92
	track_pane = gui:attach(create_pane("\f6sfx "..ct,xx,4,384,82,0x1001))
	
	local track_addr = 0x50000 + ct * 328
	-- don't expose length for now; always 64
	-- future: when change len, need to update stride to match!
	--track_pane:attach(create_tiny_num_field("len",  track_addr + 0,100,1))
	
	track_pane:attach(create_octave_chooser( 75,1))
	track_pane:attach(create_volume_chooser(145,1))
	
-- is not just play length -- dictates how data is arranged (stride between columns)
--	track_pane:attach(create_tiny_num_field("len",  track_addr + 0,230,1,  1,64))

	track_pane:attach(create_tiny_num_field("spd",  track_addr + 2,260,1))
	track_pane:attach(create_tiny_num_field("loop0", track_addr + 3,310,1))
	track_pane:attach(create_tiny_num_field("loop1",track_addr + 4,360,1))
	
	
	-- 8 segments of same track
	for i=0,7 do
		track_pane:attach(create_track_segment{
			x=2 + i * 48, y=12, rows=8,
			row0 = i*8,
			index = ct -- sfx_index
		})
	end
	
	gui:attach(create_pane("\f6pitch ",xx,90,384,88,0x1000))
		:attach(create_pitch_scribbler{
			x=0,y=10,width=384,height=76,addr=track_addr + 8,stride=64})
	
	gui:attach(create_pane("\f6volume ",xx,180,386,76,0x1000))
		:attach(create_volume_scribbler{
			x=0,y=10,width=384,height=66,addr=track_addr + 8 + 128,stride=64})
	
end

local function create_flow_toggle(el)
	el.width = 7
	el.height = 7
	el.cursor = "pointer"
	local addr = 0x30100 + cp*20+8
	function el:draw()
		poke(0x30100 + cp*20+8)
		local selected = (peek(addr) & el.bit) > 0
		--rectfill(0,0,6,6,selected and 10 or 13)
		pal(7, selected and 10 or 1)
		spr(el.icon,0,0)
		pal()
	
	end
	function el:tap()
		poke(addr, peek(addr) ^^ el.bit)
	end
	return el
end

function generate_gui_pattern()

	local pane = gui:attach(create_pane("\f6pattern "..cp,92,4,384+4,252,0x1001))
	

	pane:attach(create_octave_chooser( 75,1))
	pane:attach(create_volume_chooser(145,1))



	-- playback flow flag toggles: start, end, stop
	
	pane:attach(create_flow_toggle{
		x = 350, y = 1, bit = 0x1, icon = get_spr(58)
	})
	pane:attach(create_flow_toggle{
		x = 360, y = 1, bit = 0x2, icon = get_spr(59)
	})
	pane:attach(create_flow_toggle{
		x = 370, y = 1, bit = 0x4, icon = get_spr(60)
	})
	
	
	local container = pane:attach{
		x=0,y=24,width=pane.width,height=228,
		draw=function()	end -- to get clipping
	}

	local contents = container:attach{
		x=0, y=0, width=pane.width, height=520,
		draw = function()
			-- markers showing rows
			--[[
			fillp(0xf000)
			for i=0,7,2 do
				rectfill(0,i*64, 1000,i*64+64,16+i/2)	
			end
			fillp()
			]]
		end
		
	}
	
	-- whole track for each channel
	local chan_mask = peek(0x30100 + cp * 20 + 9)
	for i=0,7 do
	
		local sx = 2 + i*47
		local sy = 13
		local ww = 7
		
		if (chan_mask & (1 << i) > 0) then
			pane:attach(
				create_tiny_num_field("",0x30100 + cp * 20 + i, sx+15, sy)
			)
		else
			ww = 24
		end
		
		-- toggle channel bit
		pane:attach{
			x = sx+5, y = sy,
			width=ww, height = 7,
			draw=function(self)
				rect(0,0,6,6,5)
				if (chan_mask & (1 << i) > 0) then
					rect(0,0,6,6,16)
					rectfill(2,2,4,4,6)
				else
					rectfill(9,0,24,7, 0)
				end
				
			end,
			tap=function()
				chan_mask ^^= (1 << i)
				poke(0x30100 + cp*20+9, chan_mask)
				refresh_gui = true
			end
		}
		
		-- edit track
		pane:attach{
			x = sx+33, y = sy,
			width=ww, height = 7, cursor="pointer",
			draw=function(self)
				spr(23,0,0)
			end,
			tap=function()
				mode="track"
				ct=peek(0x30100 + cp * 20 + i)
				refresh_gui = true
			end
		}
	
		
		if (chan_mask & (1 << i) > 0) then
			contents:attach(create_track_segment{
				x= sx, y=0, rows=64,
				live_index = true,
				chan_i = i,
				index = peek(0x30100 + cp * 20 + i) -- track (sfx) index
			})
		else
			-- dummy
			contents:attach{
				x=sx, y=0,
				width = 44, height = 64 * 8 + 2, -- match size in create_track_segment
				draw = function(self)
					rectfill(0,0,self.width-1,self.height-1, 0)
					--rect(0,0,self.width-1,self.height-1, 5)
				end
			}
		end
		
		-- jump to channel pencil
	end
	
	container:attach_scrollbars()
		
	

end




function generate_gui()
	
	gui = create_gui()

	-- mode buttons
	
	local mode_label={[0]="inst","sfx","pat"}
	local mode_name ={[0]="instrument","track","pattern"}
	
	for i=0,2 do
		gui:attach{
			x=2 + i*29,y=4,
			width=27,height=16,
			label=mode_label[i],
			mode=mode_name[i],
			draw=function(self)
				local sel = self.mode==mode
				rectfill(0,0,self.width-1,self.height-1, sel and 14 or 1)
				print(self.label,self.width/2 - #self.label*2, 6,sel and 7 or 13)
			end,
			tap=function(self)
				checkpoint()
				mode = self.mode
				readtext(true) -- clear buffer
				refresh_gui = true
			end
		}
	end
	

	local yy = 24 -- 24
	local ww = 86 
	local pcol = mode == "instrument" and 0x0e01 or 0x0701
	local el = gui:attach(create_pane("instruments",2,yy,ww,76, pcol))
	create_instrument_chooser(el)
	yy += el.height + 4
	
	pcol = mode == "track" and 0x0e01 or 0x0701
	local el = gui:attach(create_pane("sfx",2,yy,ww,76,pcol))
	create_track_chooser(el)
	yy += el.height + 4
	
	pcol = mode == "pattern" and 0x0e01 or 0x0701
	local el = gui:attach(create_pane("patterns",2,yy,ww,72,pcol))
	create_pattern_chooser(el)
	

	if (mode == "instrument") generate_gui_instrument()
	if (mode == "track")      generate_gui_track()
	if (mode == "pattern")    generate_gui_pattern()
	
end

function generate_gui_instrument()
	
	-- add nodes to a scrollable area
	
	local node_container = gui:attach{
	
		x = 96, y = 4, width = 272, height = 252,

		mousewheel = function(self, msg)
			self.child[1].y += msg.wheel_y * 16
			self.child[1].y = mid(0, self.child[1].y, self.height - self.child[1].height)
			last_node_content_inst = ci
			last_node_content_y = self.child[1].y
		end,
		
		drag = function(self, msg)
			self.child[1].y += msg.dy
			self.child[1].y = mid(0, self.child[1].y, self.height - self.child[1].height)
			last_node_content_inst = ci
			last_node_content_y = self.child[1].y
		end,
		
		update = function(self)
			--if (self.child[1]) self.child[1].y += 1
		end
	}
	
	local node_content = node_container:attach{
		x=0,y=0,width=200,height=300
	}

	local yy = 0
	node_depth={}
	
	for i=0,7 do
	
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + i*0x20
		local node_type = peek(node_addr+1) & 0xf
		local node_parent = peek(node_addr+0) & 0x7
		
		node_depth[i] = node_depth[node_parent] and node_depth[node_parent]+1 or 0
		if (node_type == 0) node_depth[i] = -1
		
		local x0 = node_depth[i] * 8
	
		if (node_type > 0) then
			local n = node_content:attach(create_node_editor(i, x0, yy))
			if (i == 0) then
				n:attach(create_octave_chooser(80,1))
				n:attach(create_volume_chooser(145,1))
			end
			yy += n.height + 4
		end
		
		node_content.height = max(yy + 16, node_container.height)
		
		
	end
	
	
	

	-- envelopes
	local env_content = gui:attach{
		x=396,y=0,width=100,height=300
	}
	local yy = 4
	for i=0,3 do
		local inst_addr = 0x40000 + ci*0x200
		local env_addr = inst_addr + 256 + i * 24
		local e = env_content:attach(create_env_editor(i,env_addr,"env-"..i,0,yy,80))
		yy += e.height + 4
	end
	
	
	-- preserve node content scroll position
	-- to do: find a less silly way to do this
	if (last_node_content_inst == ci) then
		node_content.y = last_node_content_y
	end
	
end


:: inst.lua
--[[pod_format="raw",created="2023-10-27 18:16:38",modified="2024-04-28 08:42:00",revision=3561]]

-- 0x1702
local node_type_col = {
	[0]=0x1,0x0e05,0x0705,0x5,
	0,0,0,0,
	0x0c05,0x0c05,0x0c05,0x0c05,
	--0x1105,0x0c05,0x1905,0x0805,
}

-- labels: max 5 chars (4 preferred)

function create_mval_knob(label,node_type,mval_index,addr,x,y)

	local el = {
		x = x, y = y, 
		width = 54, -- includes the number box; and envelope connection
		height = 20,
		label=label,
		addr=addr,
		mval_index=mval_index,
		v0 = -128, v1 = 127, -- editable range for signed values
		vz = 0, -- "zero" -- where to fill pie from / until
		ac = 1, -- angle coefficient (notch angle)
		a0 = 0.0,
		-- cursor = "grab", -- to do: shouldn't set cursor while drag outside of element
		node_col = node_type_col[node_type],
		click = checkpoint,
		dval = 0,
		--cursor="grab" -- to do: dial spinning cursor that disappears
	}
	
	if (label == "vol") el.v0, el.v1 = 0, 64
	
	-- maybe later
	--if (label == "tune") el.v0,el.v1 = -120, 120 el.ac = 20 el.a0 = 0.5
	if (label == "wave") el.v0,el.v1 = 0, 255
	
	-- fx parameters are all 0..255 (flag 0x8 is not set)
	if (node_type >= 8) el.v0,el.v1 = 0, 255
		
	-- gain mix; can use *8 if want to over mix!
	if (label == "mix") el.v0, el.v1 = 0, 64
	
	
	
	function el:drop_env_plug(msg)
		--printh("setting "..pod(msg))
		poke(addr+3, msg.index)
		--set observe_envelope bit
		poke(addr, peek(addr) | 0x4)
	end
	
	
	function el:draw()
	
		--rectfill(0,0,1000,1000,8+addr/4)
			
		local xx,yy = 8.5,6.5
		
		circfill(xx-1,yy+1,7,(self.node_col&0x5 == 5) and 1 or 21)
		circfill(xx,yy,7,0)
		
		-- draw mval	
		local flags,val1,val0,env = peek(addr,4)
		local num = 1 + val1 % 16
		local den = 1 + val1 \ 16
		
		
		if (el.v1 < 128) then -- signed int8's
			if (val1 >= 128) val1 -= 256
			if (val0 >= 128) val0 -= 256
		end
		
		local range = self.v1 - self.v0
		
		-- 0.7 - 0.9 * ..
		--local p0,p1 = 0.7,0.9 -- wedge at bottom
		local p0, p1 = 0.75, 1.0 
		
		
		local a0 = self.a0 + p0 - p1 * (val1 - self.v0) * self.ac / range
		
		local a1 = p0 - p1 * (val0 - self.v0) / range
		
		
		--local a1 = self.a0 + p0 - (self.vz - self.v0) * self.ac * p1 / range
	
		-- show range (to do: decide on flags for that)
		color (peek(self.addr) & 0x4 > 0 and 12 or 14)
		
		-- ** to do: optimise **
		if (false) then  
			for k=0,1,1/(abs(a1-a0)*32) do
				local aa = a1+(a0-a1)*k
				line(xx,yy,xx+cos(aa)*6, yy+sin(aa)*6)
			end
		end
		
		-- dotty arc version

		local aa0,aa1 = a0, a1
		if (aa0 > aa1) aa0,aa1 = aa1,aa0
		for aa = -.25, .75, 1/32 do
			if (aa >= aa0 and aa <= aa1) then
				pset(xx+cos(aa)*5, yy+sin(aa)*5)
			end
		end		
		
		line(xx+cos(a0)*2, yy+sin(a0)*2, xx+cos(a0)*6, yy+sin(a0)*6, 7)

		clip()
		print(self.label, -20,4,6)
		
		rectfill(xx+7,2,xx+36,10,0)
		
		-------------------------------------------
		--   envelope assignment plug to right   --
		-------------------------------------------
		
		if (peek(self.addr) & 0x4 > 0) then
			rectfill(xx+37,2,xx+44,10,7)
			rectfill(xx+37,3,xx+45,9,7)
			
			if (peek(self.addr) & 0x8 > 0) then
				print(peek(self.addr+3)&0xf, xx+40, 3, 12)
				print("\^:1500000000000000",xx+39,9,12) -- 3 dots
			else
				print(peek(self.addr+3)&0xf, xx+40, 4, 12)
			end
		else
			-- choose randomly from range
			if (peek(self.addr) & 0x10 > 0) then
				rectfill(xx+37,2,xx+44,10,14)
				rectfill(xx+37,3,xx+45,9,14)
				print("r", xx+40, 4, 7)
			end
		end
		
		-------------------------------------------
		--      scale underneath at right        --
		-------------------------------------------
		
		local sval = peek(self.addr+3)
		
		if (sval & 0xc0 > 0) then

			str2 = (sval & 0x20 == 0) and 
				"\^:5020500000000000" or  -- *
				"\^:4020100000000000"     -- /
			
			if (sval & 0xc0 == 0x40) str2 ..= "\^:5070400000000000" -- 4
			if (sval & 0xc0 == 0x80) str2 ..= "\^:1372770000000000" -- 16
			if (sval & 0xc0 == 0xc0) str2 ..= "\^:5177470000000000" -- 64
			
			--rectfill(xx+24,11,xx+36,15,13)
			print(str2, xx+20,12,7)
		end
		
		-------------------------------------------
		--     value and parent relationship     --
		-------------------------------------------
		
		if (flags & 0x3 > 0) then
			local letter = "?"
			if (flags & 0x3 == 0x1) letter = "+"
			if (flags & 0x3 == 0x2) letter = "*"
			print(letter,35-4*4,4,3)
		end
		
		-- show value
		local str = tostr(val1)
		
		if (flags & 0x3 == 2 and label=="tune") then
			-- multiply by ratio
			-- only makes sense for pitch
			str = num.."/"..den
		end
		
		-- everything else: show raw value
		print(str, xx+35-#str*4, 4, 27)
		
		circ(xx,yy,7,13)--self.node_col&0xff)
		--circ(xx,yy,8,node_col&0xff)
		
		
	end
	
	-- turn mouse locking on while dragging
	function el:click(msg)
		mouselock(0x4|0x8, 0.5, 0.05) -- 0x4 lock 0x8 auto-release, event speed, move speed 
	end
	
	function el:drag(msg)
		local flags,val1,val0,env = peek(addr,4)
	
		local dval = (msg.dx - msg.dy)
		
		if (self.label=="tune" and (flags & 3) == 2) then
			-- special case: use u8 for integer fraction mode
			val1 = mid(0, val1 + dval, 255)
		else
			-- signed int8 behaviour
			if (el.v1 < 128) then 
				if (val0>=128) val0 -= 256
				if (val1>=128) val1 -= 256
			end
			
			if (msg.mb > 1) then
				-- drag val0 (start of range)
				val0 = mid(self.v0, val0 + dval, self.v1)
			else
				-- regular white needle dragging
				val1 = mid(self.v0, val1 + dval, self.v1)
			end	
		
		end
		
		poke(addr+1,val1)
		poke(addr+2,val0)
		return 1 -- don't drag the node content
	end
	
	function el:tap(msg)
		checkpoint()
		local flags,val1,val0,env = peek(addr,4)
		
		-- use same gui el / can still grab and drag value without
		-- having to avoid the operator area. usually operator stays
		-- untouched, so preferable to have a little friction to change it.
		
		if (msg.my > 11 and msg.mx > 34) then
			-- change scale bits
			local ctrl_held = key("ctrl")
			local val = peek(addr+3) & 0xe0
			if (val == 0)        then val = 0x00 | 0x40 -- *4
			elseif (val == 0x40) then val = 0x20 | 0x40 -- /4
			elseif (val == 0x60 and ctrl_held) then val = 0x00 | 0x80 -- *16
			elseif (val == 0x80 and ctrl_held) then val = 0x20 | 0x80 -- /16
			elseif (val == 0xa0 and ctrl_held) then val = 0x00 | 0xc0 -- *64
			elseif (val == 0xc0 and ctrl_held) then val = 0x20 | 0xc0 -- /64
			else val = 0 end
			poke(addr+3,(peek(addr+3) & ~0xe0) | val)
		elseif (msg.mx >= 18 and msg.mx <= 24) then
		
			-- change parent operator
			
			if node_type >= 8 then
				--if node_type >= 8 and (node_type!=10 or (self.mval_index!=3)) then
				-- fx filters shouldn't have any parent operators
				-- (except gain(10):mix(3)) -- update: not a useful exception; deleteme
				poke(addr, flags & ~0x3)
			elseif (flags & 0x3 > 0) then
				if (self.label == "tune") then
					poke(addr, (flags & ~0x3) | ((flags & 2 > 0) and 0 or 2))
				else
					poke(addr, flags & ~0x3) -- clear add / mult bit
				end
			else
				if (self.label == "vol" or self.label == "mix") then
					-- set bit: mult parent
					poke(addr, flags | 0x2)
				else
					-- set bit: add parent
					poke(addr, flags | 0x1)
				end
			end
		elseif (msg.mx >= 45) then
			-- toggle envelope assignment bit
			-- mb2 to toggle continuation
			if (peek(addr) & 0x4 > 0 or msg.last_mb == 1) then
				poke(addr, peek(addr) ^^ (msg.last_mb == 1 and 0x4 or 0x8))
			else
				-- toggle rnd
				poke(addr, peek(addr) ^^ 0x10)
			end
		else
			-- set val0 to val?
			-- nah -- just always drag mb2
			-- poke(addr+2,val1)
		end
	end
	
	
	return el
end

function get_mval_scale(addr)
	local val = @addr
	local bits = 0
	if (val & 0xc0 == 0) return 1
	if (val & 0x40 >  0) bits += 2
	if (val & 0x80 >  0) bits += 2
	return (val & 0x20) > 0 and 1/(1<<bits) or (1<<bits)
end


-- address is of the wavetables
function create_scope(addr, node_index, x, y, w, h)
	local el = gui:attach{
		x=x,y=y,
		width=w, height=h,
		addr=addr
	}
	function el:click(msg)
		checkpoint()
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + node_index*0x20
		local wt_index = peek(node_addr+1)>>4
		
		if (msg.mx < 18 and msg.my < 10) then
			wt_index = (wt_index + 1) % 4
			poke(node_addr+1, (peek(node_addr+1) & ~0xf0) | (wt_index << 4))
		end
	end
	
	function el:draw(msg)
		rectfill(0,0,self.width,self.height,0)
		--if (1) return
		
		-- grab instrument attributes
		local inst_addr = 0x40000 + ci*0x200
		local node_addr = inst_addr + node_index*0x20
		local node_type = peek(node_addr+1) & 0xf
		local wave_addr = node_addr + 4 + 4*4
		local wave_val  = peek(wave_addr+1)
		
		-- wavetable
		local wt_index = (peek(node_addr+1)>>4)
		local wt_addr = el.addr + wt_index * 4
		local addr0, addr1, width_bits, wt_height = peek(wt_addr,4)
		local dat_addr = (addr0 << 8) | (addr1 << 16)
		local wt_width = 1 << width_bits
		
		dat_addr += (wave_val * wt_height >> 8) * wt_width*2
		
		local phase_addr = node_addr + 4 + 5*4
		local phase_val  = (peek(phase_addr+1) + 128) % 256 - 128
	
		local stretch_addr = node_addr + 4 + 5*4
		local stretch_val  = 0--peek(stretch_addr+1)
		
		if (stretch_val >= 128) stretch_val -= 256
		stretch_val = (stretch_val + 128) / 128 -- 0..2
		
	
		local vol_addr = node_addr + 4 + 0*4
		local vol_val  = peek(vol_addr+1)
		
		-- osc when nothing is playing: visualise waveform
		if (node_type == 2 and not something_is_playing) then
			line()
			for i = 0,self.width-1, .5 do
				local samx = i / self.width
				samx += phase_val/256
				samx = (samx * stretch_val) % 1
				
				local i2 = flr(samx * wt_width)
				local val = peek2(dat_addr + i2*2)
				val *= (vol_val/0x40)
				
				local xx = i
				local yy = self.height/2 - val * self.height/72000
				--line(xx,yy,11)
				pset(xx,yy, pget(xx,yy) == 3 and 11 or 3)
			end
			
			print("wt-"..wt_index,2,2,3)
			return
		end
		
		-- filter: always show visualisation
		if (node_type == 8) then
			local low    = peek(node_addr + 4 + 0*4 + 1) / 255.0
			local high   = peek(node_addr + 4 + 1*4 + 1) / 255.0
			local res    = peek(node_addr + 4 + 2*4 + 1) / 255.0
			
			-- to do: calculate cutoff in Hz or something?
	
			return
		end
		
	
		-- delay: always show visualisation
		if (node_type == 9) then
			local delay   = peek(node_addr + 4 + 0*4 + 1)
			local vol     = peek(node_addr + 4 + 1*4 + 1) / 255.0
			local ww = self.width \ 7
			local hh = self.height - 4
			for i=0,6 do
				 local xx=2+ww*i
				 rectfill(xx+1,self.height-2,xx+ww-2,self.height-2-hh,12)
				 hh *= vol
			end
			return
		end
		
		
		-- gain: always show visualisation
		if (node_type == 10) then
		
			local gain  = peek(node_addr + 4 + 0*4 + 1) * 7.0 / 255.0
			gain = 1.0 + gain * get_mval_scale(node_addr + 4 + 3)
			
			local elbow = peek(node_addr + 4 + 1*4 + 1) / 255.0
			elbow *= get_mval_scale(node_addr + 4 + 1*4 + 3)
			
			local cut   = 1.0 - peek(node_addr + 4 + 2*4 + 1) / 255.0
			local mix   = peek(node_addr + 4 + 3*4 + 1)
			local ww = self.width
			local hh = self.height
			
			
			fillp(0x5555)
			line(0, hh - cut * hh, ww, hh - cut * hh, 13)
			fillp()
			
			local elbow_y = cut
			local elbow_x = elbow_y / gain
			local slope = 0
			
			if (elbow_x == 1.0) then
				slope = 0
			elseif (elbow < 0.5) then
			
				local tt = elbow * 2
				local slope0 = (gain-elbow_y) / (1-elbow_x)
				local slope1 = (1-elbow_y) / (1-elbow_x)
				slope = (1-tt) * slope0 + (tt * slope1)
			else
				local tt = (elbow-.5)*2
				local slope0 = (1-elbow_y) / (1-elbow_x)
				slope = (1-tt) * slope0
			end
			
			for i = 0,self.width-1, .5 do
				local tt = i / self.width
				local val=0
				
				if tt < elbow_x then
					val = tt*gain
				else
					if elbow < 1 then
						val = elbow_y + (tt-elbow_x)*slope
					else
						-- foldback \m/
						local e2 = elbow-1
						local h2 = elbow_y / 2
						val = h2 + cos((tt-elbow_x)*e2) * h2
					end
				end
				
				local xx = i
				local yy = self.height - val * self.height
			
				pset(xx,yy, pget(xx,yy) == 3 and 11 or 3)
			end
			
			--[[
			elbow_x *= self.width
			elbow_y = cut * self.height
			line(0,hh-1,elbow_x,hh-elbow_y, 7)
			if (elbow < .5) then
				-- no cut   -->  soft cut
				local tt = elbow * 2
				line(ww, hh - (gain*hh * (1-tt) + hh*tt) )
			else
				-- soft cut -->  hard cut
				local tt = (elbow-.5) * 2
				line(ww, hh - (hh * (1-tt) + hh*cut*tt) )
			end
	
			line(ww,0)
			]]
			
			return
		end
		
		--------- live output ----------
		
		ci_channel = 8 -- ** assume channel 0
		
		if (ci_channel < 0) return -- don't know which channel [yet?] -- skip
		
		-- tick_len is never larger than 4k
		local tick_addr = 0x200000 + node_index * 8192
		
		local tick_len = stat(400 + ci_channel, 8)

		-- grab at 15fps (perf + so is readble)
		--if ((global_t + node_index) & 3 == 0 and (not msg.has_pointer or msg.mb==0)) 
		if (true)
		then
			tick_len = stat(400 + ci_channel, 20 + node_index, tick_addr)
		end
		
		for i = 0,self.width-1, .5 do
			local i2 = i\.5 -- 2 samples per pixel
			local val = peek2(tick_addr + i2*2)
			local yy = self.height/2 - val * self.height/72000
			pset(i,yy, pget(i,yy) == 3 and 11 or 3)
		end
		
		--print(tick_len, 20, 20, 11)
		
	end
	return el
end	


function create_muted_node_toggle(addr,x,y)
	local el = { 
		addr = addr,
		x = x, y = y, width = 7, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & 0x2
		clip()
		pal(7,1)
		spr((val & 0x2 > 0) and 57 or 56,0,0+yy)
		pal()
	end
	function el:tap()
		checkpoint()
		local val = peek(self.addr)
		val ^^= 0x2
		poke(self.addr, val)
		--refresh_gui = true
	end
	
	return el
end

function delete_node(index)
	local inst_addr = 0x40000 + ci*0x200
	-- move everything up
	for j=index, 7 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j+1) * 0x20, 0x20)
	end
	memset(inst_addr + 7 * 0x20, 0, 0x20)
	refresh_gui = true
end

function create_child_node(parent_index, node_type, is_modulator)
	checkpoint()
	local inst_addr = 0x40000 + ci*0x200
	
	-- find slot after sub-tree ends
	local child_index = parent_index
	for i = parent_index+1, 7 do
		if (node_depth[i] and node_depth[i] > node_depth[parent_index])
		then
			-- printh(pod{i,node_depth[i],node_depth[parent_index]})
			child_index = i -- still in sub-tree
		end
	end
	child_index += 1 -- slot after sub-tree
	
	if (is_modulator) then
	
		child_index = parent_index + 1
		
		local node_addr = inst_addr + child_index*0x20
		local node_type = peek(node_addr+1) & 0xf
	
		-- already a node with a modulating operator: refuse to create
		if (peek(node_addr)>>4) > 0 then
			return
		end
		
	end
	
	--printh("@@ inserting child at "..child_index)	
	
	if (child_index >= 8) return -- no space!!
	
	local node_addr = inst_addr + child_index*0x20
	
	-- shunt everything else down
	for j=7,child_index+1, -1 do
		memcpy(inst_addr + j * 0x20, inst_addr + (j-1) * 0x20, 0x20)
	end
		
	-- init rest of node to something sensible.
	
	memset(node_addr, 0, 0x20)
	
	if (node_type == 0x2 and is_modulator) then
		poke(node_addr,
			parent_index | 16, node_type, 0, 0,
			0x0,0x20,0,0,  -- volume:absolute
			0x0,0,0,0,     -- pan:  not used
			0x1,0,0,0,     -- tune: parent+0 -- not quantized
			0x1,0,0,0,     -- bend: parent+0
			0,0,0,0,       -- waveform
			0x0,0,0,0      -- phase
		)
	elseif (node_type == 0x2) then
		poke(node_addr,
			parent_index, node_type, 0, 0,
			0x2,0x20,0,0,  -- volume: mult. 0x40 is max (-0x40 to invert, 0x7f to overamp)
			0x1,0,0,0,     -- pan:  parent+0
			0x21,0,0,0,    -- tune: parent+0   0x20 quantized;
			0x1,0,0,0,     -- bend: parent+0
			0,0,0,0,       -- waveform
			0x0,0,0,0      -- phase
		)
		
	else
		-- fx: no parent ops
		poke(node_addr,
			parent_index, node_type, 0, 0
			-- all zero: fx knobs are all uint8, so don't need 0x8 flags set
		)
	end
	
	refresh_gui = true
end


local node_op_str={
	[0]="carrier","fm mod","ring mod", "xor","or"
}
function create_op_toggle(addr,x,y)
	local el = { 
		addr = addr, cursor="pointer",
		x = x, y = y, width = 40, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) >> 4
		clip()
		pal(7,1)
		rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 6)--6+val*3)
		--spr(val,1,1+yy)
		print(node_op_str[val],2,1+yy,1)
		pal()
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr) >> 4
		if (val > 0) then
			val = val == 1 and 2 or 1
			poke(self.addr, (peek(self.addr) & 0xf) | (val << 4))
		end
		--refresh_gui = true
	end
	
	return el
end

local node_fx_str={
	[8]="filter",[9]="echo",[10]="shape", [11]="crush"
}
function create_fx_type_toggle(addr,x,y)
	local el = { 
		addr = addr,
		x = x, y = y, width = 40, height = 7
	}
	function el:draw(msg)
		local yy = (msg.has_pointer and msg.mb > 0) and 1 or 0
		local val = (@self.addr) & 0xf
		clip()
		pal(7,1)
		rectfill(0,0+yy,self.width-1,6+yy,msg.has_pointer and 14 or 6)
		--spr(val,1,1+yy)
		print(node_fx_str[val],2,1+yy,1)
		pal()
	end
	function el:click()
		checkpoint()
		local val = peek(self.addr)
		val = 8 + (((val-8) + 1) % 3) -- only need filter, echo, gain
		poke(self.addr, (peek(self.addr) & 0xf0) | (val & 0x0f))
		refresh_gui = true
	end
	
	return el
end


local node_type_str={
[0]="none", "instrument","osc:","alias",
"","","","",
"fx:","fx:","fx:","fx:"
}

local mval_dat = {
	{"vol","pan","tune","bend","p0","p1"},
	{"vol","pan","tune","bend","wave","phase"},
	nil,
	nil,nil,nil,nil,
	-- really want fx boxes to be tiny and specialized
	-- (and to cost nodes! -- they are generally expensive on host)
	-- to do: standard "clip" for all fx nodes
	-- 0..127 means clip to max..osc_vol  128..255 means clip to osc_vol..0
	{"low","high","res"},
	{"delay","vol"},
	{"gain","elbow","cut","mix"},
	{"resx","resy","lpf"}, -- can adjust the sample rate, sample precision
}


function create_node_editor(node_index, x, y)

	local inst_addr = 0x40000 + ci*0x200
	local node_addr = inst_addr + node_index*0x20
	local node_type = peek(node_addr+1) & 0xf
	local node_op = peek(node_addr) >> 4
	
	local labels = mval_dat[node_type] or {}
	
	local width = 240
	
	local rows = 3
	if (node_type == 1) rows=2
	if (node_type >= 8) rows=2 --width = 118
	
	local height = 20 + rows * 16
	
	
	
	local desc = node_type_str[node_type] or "??"
	--if (node_type == 2) desc ..= " "..(node_op_str[node_op] or "??")
	
	local head_col = node_type_col[node_type]
	if (node_type == 2 and node_op > 0) head_col = 0xd05

	local el = gui:attach(create_pane("  "..desc, x, y, width, height, head_col))
		
	-- active / not active toggle
	el:attach(create_muted_node_toggle(node_addr+2, 3,1))
	
	-- operator button for oscillator children
	if (node_type == 2) then
		el:attach(create_op_toggle(node_addr, 34,1))
	end
	
	if (node_type >= 8) then
		el:attach(create_fx_type_toggle(node_addr+1, 30,1))
	end
	
	
	-- child creation buttons for oscillators / root
	if (node_type < 4) then
		local xx=el.width-72
		if (node_type == 1) xx += 30
		
		if (node_type == 2) then -- +mod only for carrier osc
		xx += el:attach{
			x=xx,y=1,width=19,height=7,cursor="pointer",
			draw = function(this,msg)
				rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
				print("+mod",2,1,5)
			end,
			tap = function() create_child_node(node_index,2,true) end
		}.width+2
		end
		xx+=el:attach{
			x=xx,y=1,width=19,height=7,cursor="pointer",
			draw = function(this,msg)
				rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
				print("+osc",2,1,5)
			end,
			tap = function() create_child_node(node_index,2) end
		}.width+2
		
		xx+=el:attach{
			x=xx,y=1,width=15,height=7,cursor="pointer",
			draw = function(this,msg)
				rectfill(0,0,this.width,this.height,msg.has_pointer and 23 or 6) 
				print("+fx",2,1,5)
			end,
			tap = function() create_child_node(node_index,8) end
		}.width+2
	end
	
	-- delete node
	if (node_type > 1) then
	el:attach{
		x=el.width-10,y=1,width=8,height=7,cursor="pointer",
		draw = function(this,msg)
			rectfill(0,0,this.width,this.height,msg.has_pointer and 8 or 6) 
			print("X",2,1,5)
		end,
		tap = function() delete_node(node_index) end
	}
	end
	
	
	-- knobs
	
	for y=0,rows-1 do for x=0,y==2 and rows-1 or 1 do
		local mval_index = y*2 + x
		local label = labels[mval_index+1] or "??"
		if (mval_index < #labels and label ~= "pan") then -- turn off panning for now!
			el:attach(create_mval_knob(label, node_type, mval_index,
				node_addr + 4 + mval_index*4, 26 + x*80, 13 + y*18))
		end
	end end
	
	el:attach(create_scope(inst_addr+0x1e0,node_index,164,14, 69, el.height-19))

	return el
end



































































:: main.lua
--[[pod_format="raw",created="2023-10-22 07:30:04",modified="2024-04-28 08:42:00",revision=8523,stored="2023-36-29 04:36:40"]]
--[[
	Picotron Tracker
	(c) Lexaloffle Games LLP
]]

include "data.lua"
include "inst.lua"
include "track.lua"
include "env.lua"
include "pat.lua"
include "gui.lua"
include "update.lua"
include "undo.lua"

include "debug.lua"

function _init()
	
	poke(0x4000, get(fetch"/system/fonts/p8.font"))
	
	window{
		tabbed=true,
		icon = userdata"[gfx]08080077777700700007007000070070000700700777777007777770000000000000[/gfx]",
		title="sfx"
	}
	
	mkdir "/ram/cart/sfx"
	
	wrangle_working_file(
		function()
			local ud = userdata("u8",0x40000)
			for i=0,0x3f do
				set(ud, i * 0x1000, peek(0x30000 + i * 0x1000, 0x1000))
			end
			return ud
		end,
		function (ud)
			if (type(ud)~="userdata") then
				init_data()
			else
				for i=0,0x3f do
					poke(0x30000 + i * 0x1000, get(ud, i * 0x1000, 0x1000))
				end
			end
			tdat={}
			init_undo()
		end,
		"/ram/cart/sfx/0.sfx"
	)
	
	

	-- current instrument, node, pattern, track
	ci = 1
	cn = 0
	cp = 0
	ct = 0
	
	cvol = 0x20
	coct = 4
	
	mode = "track"
	
	init_undo()
	
end

-- for mocking up
function draw_pane(title, x, y, w, h, col)
	col = col or 5
	y = y + 2
	rectfill(x,y,x+w-1,y+h-1,col)
	rectfill(x,y,x+w-1,y+6,7)
	print(title,x+4,y+1,1)
	
	--pset(x,y,0) pset(x+w-1,y,0)
	--pset(x,y+h-1,0)	pset(x+w-1,y+h-1,0)
end


function draw_node_attr(label, x, y)

--	rectfill(x, y, x+60, y+8, 6)


	rectfill(x+30,y,x+70,y+8,0)

	-- *2.0+1 means *2.0 relative to parent,  +1 semitone
	-- special for tune. click label to toggle between *2.0+1 and +1
	-- other attributes: click label to toggle between 1.0 and *1.0

	if (label == "tune") then
		print("*2.00+1",x+42,y+2, 13)
	else
		print("1.000",x+47,y+2, 13)
	end

	circfill(x+30,y+4,7,0)
	circ    (x+30,y+4,7,7)
	
	
	print(label, x+2, y+2, 6)

end

function _draw()


	--fillp(1)
	--fillp(~0x813d)
	fillp(~0x8239) -- brushed metal? something industrial
	rectfill(0,0,480,270,32 | (33*256))
	fillp()
	
	--rectfill(368,0,480,270,5)
	--rectfill(0,0,108,270,5)
	
--[[
	draw_pane("song info", 2,2,96,56,1)
	draw_pane("instruments",2,62,96,98,1)
	--draw_pane("mudo state",2,164,96,90,0)
]]
	
	
	-- operations during _update can request a
	-- gui update before it is next draw (avoid flicker)
	if (refresh_gui or not gui) then
		readtext(true) -- clear text input buffer
		generate_gui()
		-- gui:draw_all() expects :update_all() called first on current state of gui
		gui:update_all()
		refresh_gui = false
	end
	
	gui:draw_all()
	
	-- custom display palette
	-- at end.. something in :draw_all() probably calls pal()
	poke4(0x5000+32*4, 0x202020)
	
	--poke4(0x5000+32*4, 0xf020f0) -- debug flashing
	
	-- print(string.format("cpu:%3.3f",stat(1)),440,250,7)
	--draw_mudo_state(380,200)
	
	
end



:: pat.lua
--[[pod_format="raw",created="2024-25-09 02:25:26",modified="2024-33-09 02:33:23",revision=55]]


:: track.lua
--[[pod_format="raw",created="2023-10-27 18:49:18",modified="2024-04-28 08:42:00",revision=4438]]
--[[

	track editor

]]


function create_tiny_num_field(label,addr,x,y,  vmin, vmax)
	local el={
		x=x,y=y,
		width=15,height=14,
		label=label,addr=addr,
		vmin=vmin, vmax=vmax
	}
	
	function el:draw()
		local val=peek(self.addr)
		if (has_knob) then
			circ(7,5,5,13)
			local aa=.7-val*.9/255.0
			line(7.5+cos(aa),5.5+sin(aa),7.5+cos(aa)*4,5.5+sin(aa)*4,7)
		end
		
		clip()
		
		-- 
		local yy= 0
		rectfill(0,yy,14,yy+6,0)
		local str=tostr(val)
		print(str,14-#str*4,yy+1,3)
		
		local label = self.label
		if (label == "loop0" and peek(self.addr+1) <= val) label = "len"
		print(label,-(2+#label*4),yy+1,6)

	end
	
	function el:click(msg)
		mouselock(0x4|0x8, 0.25, 0.05) -- 0x4 lock 0x8 auto-release, event speed, move speed 
	end
	
	
	function el:drag(msg)
		local val=peek(self.addr)
		val += msg.dx - msg.dy
		local vmin = el.vmin or 0
		local vmax = el.vmax or 255
		
		val = mid(vmin,val,vmax)
		poke(self.addr, val)
	end
	
	return el
end


cur_x = 0
cur_y = 0x50000 + 8

local note_name = {[0]=
"c ","c#","d ","d#","e ","f ","f#","g ","g#","a ","a#","b "
}
local val_to_str_0xff = {}
local val_to_str_0x00 = {}
local val_to_note     = {}

for i=0,255 do
	val_to_str_0xff[i] = string.format("%02x",i) 
	val_to_str_0x00[i] = string.format("%02x",i) 
	val_to_note[i] = note_name[i%12]..(i\12)
end

--val_to_str_0x00[0x00] = ".."
val_to_str_0xff[0xff] = ".."
val_to_note    [0xff] = "..."

local function render_row(addr, stride)
	
	local freq = @addr addr += stride
	local inst = @addr addr += stride
	local vol  = @addr addr += stride
	local fx   = @addr addr += stride
	local fxp  = @addr

	-- to do: cpu cost for string.format
	-- could keep a large cache by int64 hash of input
	return string.format("%s\-h\fe%s\-h\fc%s\-h\fd%s\f6%s",
		val_to_note[freq],
		val_to_str_0xff[inst], val_to_str_0xff[vol],
		fx == 0 and "." or chr(fx),
		fx == 0 and ".." or val_to_str_0x00[fxp]
	)
	
end

local function render_selection(x0, x1)

	local str=""
	local str1 = "  "
	for i=0,8 do
		if (x0 <= i and x1 >= i) then
			str..= "\^i"..str1.."\^-i"
		else
			str..= str1
		end
		str1 = " " -- subsequent items are a single character
		if (i == 0 or i == 2 or i == 4) str1 ..= "\-h" -- 1px space
	end
	

	return str
--[[
	return string.format("%s%s\-h%s\-h%s\-h%s%s",
		(x0 <= 0 and x1 >= 0) and "\^i  \^-i" or "  ",
		(x0 <= 1 and x1 >= 1) and "\^i \^-i" or " ",
		(x0 <= 2 and x1 >= 2) and "\^i  \^-i"  or "  ",
		(x0 <= 3 and x1 >= 3) and "\^i  \^-i"  or "  ",
		(x0 <= 4 and x1 >= 4) and "\^i \^-i"   or " ",
		(x0 <= 5 and x1 >= 5) and "\^i  \^-i"  or "  "
	)
]]
end

-- by sfx_index; could do by channel later esp
-- if playing same sfx on two diffrent channels
function playing_row(sfx_index)

	if (stat(464)==0) return nil -- nothing playing
	
	for i=0,7 do
		if (stat(400 + i, 12) == sfx_index) then
			--printh("playing_row for sfx "..sfx_index..": "..stat(400 + i, 9))
			return stat(400 + i, 9)
		end
	end
end

function create_track_segment(el)

	local row_h = 8
	
	el.x = el.x or 0
	el.y = el.y or 0
	el.rows    = el.rows or 32
	el.width   = 44 -- always 48
	el.height  = el.height or el.rows * row_h + 2
	el.row0    = el.row0 or 0
	el.index   = el.index or ct -- sfx index
	
	el.rowstr={}
	
	
	if (not tdat[el.index]) tdat[el.index] = {}
	local ddat = tdat[el.index] -- decoration data
	
	-- recall per-sfx cursor
	if (ddat.cur) then
		cur_x = ddat.cur.x
		cur_y = ddat.cur.y
	end
	
	--tdat[el.index].sel={x0=0,y0=0,x1=3,y1=5}

	-- e.g. 0x50008 for first element on first row of first track
	-- add + el.row0 to get address of first row in segment	
	local base_addr = 0x50000 + (el.index * 328) + 8
	
	function el:update()
		if (el.live_index) then
			el.index = peek(0x30100 + cp * 20 + el.chan_i)
			base_addr = 0x50000 + (el.index * 328) + 8
		end
		ddat.cur={x=cur_x,y=cur_y} -- store per-sfx cursor
	end
	

	function el:draw()
	
		local sel = ddat.sel
		
		rectfill(0,0,1000,1000,0)
				
		for i = 0, self.rows-1 do
		
			if (i%8 == 0 and self.rows > 8) then
				rectfill(0,i*row_h, self.width-1,i*row_h+row_h, i == 32 and 2 or 21)
			end
			
			if (i + self.row0 == playing_row(el.index)) then
				rectfill(0,i*row_h, self.width-1,i*row_h+row_h, 18)
			end
		
			-- note(3) inst(2) vol(2) effect(3)
			
			--print("c 3\-h\fe..\-h\fc..\-h\fd..0", 1, 1+i*7, 6)
			
			-- selected
			if (sel and i + el.row0 >= sel.y0 and  i + el.row0 <= sel.y1 and
				sel.y0 ~= sel.y1) 
			then
				print(render_selection(sel.x0, sel.x1), 1, 1+i*row_h, 10)
			end
			
			-- single
			
			if (cur_y == base_addr + i + el.row0) then
				print(render_selection(cur_x, cur_x), 1, 1+i*row_h, 10)
			end
			
			print(render_row(base_addr + i + el.row0, 64), 1, 2+i*row_h, 6)
			
		end
		
		--rectfill(43,0,45,self.rows*7-3,16)
		
	end
	
	function el:click(msg)
	
		checkpoint()
		
		local i=(msg.my-2)\row_h
		cur_y = base_addr + i + el.row0
		ct = el.index
		
		--	printh(string.format("base_addr: %x i: %d", base_addr, i))
		
		
		local col_x = {[0]=0,8,13,17,22,26,31,35,39}
		for i=0,8 do
			if (msg.mx >= col_x[i]) cur_x = i
		end

		if (key"shift") then
			ddat.sel=ddat.sel or {x0=cur_x, y0=i + el.row0, x1=cur_x, y1=i + el.row0}
			ddat.sel.x1 = cur_x
			ddat.sel.y1 = i + el.row0
		else
			ddat.sel = {x0=cur_x, y0=i + el.row0, x1=cur_x, y1=i + el.row0}
		end
		
	
	end
	
	function el:drag(msg)
		local i=(msg.my-2)\row_h
		cur_y = base_addr + i + el.row0
		local col_x = {[0]=0,8,13,17,22,26,31,35,39}
		for i=0,8 do
			if (msg.mx >= col_x[i]) cur_x = i
		end
		ddat.sel.x1 = cur_x
		ddat.sel.y1 = i + el.row0
	
	end
	
	return el
end


function create_pitch_scribbler(el)
	el.index 	= el.index or ct
	el.click 	= checkpoint
	local y_offset = 12
	function el:draw()
		line(0,self.height-1,self.width,self.height-1,1)
		for i=0,63 do
			local val = (@(el.addr + i))
			if (val ~= 0xff) then
				local xx = i * 6
				local inst = @(el.addr + i + el.stride)
				local yy = el.height - val - 1 + y_offset
				rectfill(xx+1, yy, xx + 4, el.height, i==playing_row(el.index) and 12 or 1)
				rectfill(xx+1, yy, xx + 4, yy+1 , 8 + inst%24)
			end
		end
		local track_addr = 0x50000 + ct * 328
		local xx = peek(track_addr+3)*6
		if (xx>0) line(xx,0,xx,self.height,12)
		local xx1 = peek(track_addr+4)*6
		if (xx1>xx) line(xx1,0,xx1,self.height,14)
	end
	
	function el:drag(msg)
		local xx  = mid(0, msg.mx \ 6, 63)
		local val = mid(0, el.height - msg.my + y_offset, 255)
		poke(el.addr + xx, val)
		poke(el.addr + xx + el.stride, ci) -- set instrument
		local vol_addr = el.addr + xx + el.stride*2
		if (@vol_addr == 0xff) poke(vol_addr, 32) -- set volume when undefined
	end
	
	return el
end


-- dupe
function create_volume_scribbler(el)
	el.index 	= el.index or ct
	el.click  	= checkpoint
	function el:draw()
		line(0,self.height-1,self.width,self.height-1,1)
		for i=0,63 do
			local val = @(el.addr + i)
			if (val ~= 0xff) then
			local xx = i * 6
			local yy = el.height - val - 1
			rect(xx+1, yy, xx + 4, yy, i==playing_row(el.index) and 7 or 12)
			end
		end
	end
	
	function el:drag(msg)
		local xx  = mid(0, msg.mx \ 6, 63)
		local val = mid(0, el.height - msg.my, 99)
		poke(el.addr + xx, val)
	end
	
	return el
end


function update_track_editor()
	
	local row0_addr = 0x50000 + (ct * 328) + 8
	local stride = 64
	local max_addr = row0_addr + 63
	
	-- can play even when cursor is not in range
	if (keyp("space")) then
		if (something_is_playing) then
			-- stop all audio when something was playing
			note()
		else
		
			local start_row = 0
			-- to do: setting to play from cursor instead of group of 8
			if (key"shift") then
				-- safety; condition always true
				if (cur_y > row0_addr) start_row = (cur_y-row0_addr) & ~0x7
			end
			
			-- play on channel 0
			if (mode == "track") sfx(ct, 0, start_row, 0)
			if (mode == "pattern") music(cp)
		end
	end
	
	-- select
	
	if (key("ctrl") and keyp("a")) then
		checkpoint()
		tdat[ct].sel = {x0=0,y0=0,x1=8,y1=63}
	end
	
	-- paste notes
	if key("ctrl") and keyp("v") then
		checkpoint()
		local dat = unpod(get_clipboard())
		if (dat and type(dat.notes) == "userdata") then
			local x0=tonum(dat.x0) or 0
			local x1=tonum(dat.x1) or 8
			local maxy = min(dat.notes:height()-1, 63-(cur_y-row0_addr))
			notify(string.format("pasting %d %d %d",x0, x1, maxy))
			for y=0,maxy do
				if (x0<=1) poke(cur_y+y,dat.notes:get(0,y))
				if (x0<=3 and x1>=2) poke(cur_y+y+64,dat.notes:get(1,y))
				if (x0<=5 and x1>=4) poke(cur_y+y+128,dat.notes:get(2,y))
				if (x0<=6 and x1>=6) poke(cur_y+y+192,dat.notes:get(3,y))
				if (x0<=8 and x1>=7) poke(cur_y+y+256,dat.notes:get(4,y))
			end
		else
			notify("could not find note data to paste")
		end
	end
	
	-- operations on selections
	
	if (tdat[ct] and tdat[ct].sel and tdat[ct].sel.y0 ~= tdat[ct].sel.y1) then
		local sel = tdat[ct].sel
		local x0,y0,x1,y1 = sel.x0,sel.y0,sel.x1,sel.y1
		
		-- remove selection
		if (keyp("enter")) tdat[ct].sel = nil return
		
		local did_cut = false
		
		-- copy note data
		-- always all vals but record range to write on paste
		if key("ctrl") and (keyp("x") or keyp("c")) then
			did_cut = keyp("x")
			local ud = userdata("u8",5,y1-y0+1)
			for x=0,4 do
				for y=y0,y1 do
					ud:set(x,y-y0,peek(row0_addr+x*64+y))
				end
			end
			set_clipboard(pod({
				notes=ud,
				x0=x0, x1=x1
			},7,{pod_type="notes"}))
			notify("copied "..(y1-y0+1).." notes")
		end
		
		-- clear (also use after cutting)
		-- to do: allow clearing at the nibble level
		if (keyp("backspace") or keyp("delete") or did_cut) then
			checkpoint()
			for y=y0, y1 do
				if (x0<=1) poke(row0_addr+y,0xff)
				if (x0<=3 and x1>=2) poke(row0_addr+y+64,0xff)
				if (x0<=5 and x1>=4) poke(row0_addr+y+128,0xff)
				if (x0<=6 and x1>=6) poke(row0_addr+y+192,0)
				if (x0<=8 and x1>=7) poke(row0_addr+y+256,0)				
			end
		end
		
			
		--------------------------------------
		readtext(true) -- discard any leftover keypresses
		return	
		--------------------------------------
	end
	
	-- might still copy pattern
	if (mode == "pattern" and key"ctrl" and keyp"c") then
		local addr = 0x30100 + cp*20
		local ud=userdata("u8",20)
		ud:set(0,peek(addr, 20))
		set_clipboard(pod({
			pattern=ud
		},7,{pod_type="pattern"}))
		notify("copied pattern")
	end
	
	if (mode == "pattern" and key"ctrl" and keyp"v") then
		checkpoint()
		local dat = unpod(get_clipboard())
		if (dat and type(dat.pattern) == "userdata") then
			poke(0x30100 + cp*20, get(dat.pattern, 0, 20))
			notify("pasted pattern")
			refresh_gui = true
		else
			notify("could not paste pattern or track data")
		end
	end
	
	-- to do: cur_y per track
	-- cursor isn't in current track; don't allow editing
	
	if (cur_y < row0_addr or cur_y >= row0_addr + 64) then
	
		readtext(true) -- consume (and ignore) any text entry

		--------------------------------------
		return	 
		--------------------------------------
	end
	

	
	if key"ctrl" then
	
		readtext(true) -- clear buffer
		
		--------------------------------------
		return -- nothing else to process
		--------------------------------------
	end
	
	if (keyp("left"))  cur_x -= 1
	if (keyp("right")) cur_x += 1
	if (keyp("up"))    cur_y -= 1
	if (keyp("down"))  cur_y += 1
	if (keyp("pageup"))    cur_y -= 4
	if (keyp("pagedown"))  cur_y += 4
	
--[[
	to do: how to handle limits? track vs pattern
	while (cur_y <  0x50008+ct*328+00) cur_y += 64
	while (cur_y >= 0x50008+ct*328+64) cur_y -= 64
]]
	--printh(string.format("%x",cur_y))
	
	-- going over means diffrent things depending on layout
	-- just wrap for now
	cur_x %= 9
	
	-- enter data
	
	local q = 64 -- stride
	
	-- key_pitch: use scancodes rather than textinput
	
	if (cur_x == 0) then
		for i=1,#key_pitch do
			if keyp(sub(key_pitch,i,i)) then
				poke(cur_y, 35+i + (coct*12-48))
				if (peek(cur_y+q)   == 0xff) poke(cur_y + q,   ci)   -- set inst
				if (peek(cur_y+q*2) == 0xff) poke(cur_y + q*2, cvol) -- set volume
				
				-- play the track from that note
				sfx(ct, 0, cur_y-row0_addr, 1)
				cur_y += 1
			end
		end
	end
	
	if (keyp("del") or (keyp("backspace") and cur_y > row0_addr)) then
		checkpoint()
		if (keyp("backspace")) cur_y -= 1
		for addr = cur_y, max_addr-1 do
			for j=0,4 do
				poke(addr + j*stride, peek(addr+j*stride+1))
			end
		end
		for j=0,4 do
			poke(max_addr + j * stride, j > 2 and 0 or 0xff) -- blank last line
		end
	end
	
	if (keyp("enter") and cur_y < max_addr) then
		checkpoint()
		for addr = max_addr, cur_y+1, -1 do
			for j=0,4 do
				poke(addr + j*stride, peek(addr+j*stride-1))
			end
		end
		for j=0,4 do
			poke(cur_y + j * stride, j > 2 and 0 or 0xff) -- blank current line
		end
		cur_y += 1
	end
	
	-----
	
	while peektext() do
	
		local c = readtext()
	
		checkpoint()
			
		-- fx
		if (cur_x >= 6) then
			
			-- only PICO-8 effects
			--[[
			if (c >= "0" and c <= "7") or c=="." then
				poke(cur_y + q*3, (c == "." or c == "0") and 0 or ord(c))
				cur_y += 1
			end
			]]
			notify("[tracker effects coming soon!]")
		else

			local num = nil
			
			if (c >= "a" and c <= "f") num = 10 + ord(c) - ord("a")
			if (c >= "A" and c <= "F") num = 10 + ord(c) - ord("A")
			if (c >= "0" and c <= "9") num = 00 + ord(c) - ord("0")
			
			if (num) then
				if (cur_x == 1) poke(cur_y, num*12 + peek(cur_y) % 12)
		
				if (cur_x >= 2 and cur_x <= 3 and peek(cur_y+q) == 0xff) poke(cur_y+q,0)
				if (cur_x == 2) poke(cur_y + q, peek(cur_y + q) % 16 + num * 16)
				if (cur_x == 3) poke(cur_y + q, peek(cur_y + q) &~15 | num )
		
				-- volume
				if (cur_x >= 4 and cur_x <= 5 and peek(cur_y+q*2) == 0xff) poke(cur_y+q*2,0)
				if (cur_x == 4) poke(cur_y + q*2, peek(cur_y + q*2) % 16 + num * 16)
				if (cur_x == 5) poke(cur_y + q*2, peek(cur_y + q*2) &~15 | num )
		
				-- fxp: commented until the mixer can deal with them!
				--[[
				if (cur_x >= 7 and cur_x <= 8 and peek(cur_y+q*4) == 0xff) poke(cur_y+q*4,0)
				if (cur_x == 7) poke(cur_y + q*4, peek(cur_y + q*4) % 16 + num * 16)
				if (cur_x == 8) poke(cur_y + q*4, peek(cur_y + q*4) &~15 | num )
				if (cur_x > 0) cur_y += 1
				]]
				
				--cur_y += 1
				if (cur_x > 0) cur_y += 1
			end
			
			-- . button to set whole byte for 
			if (c == ".") then
				if (cur_x == 0 or cur_x == 1) poke(cur_y + q*0, 0xff) cur_y += 1
				if (cur_x == 2 or cur_x == 3) poke(cur_y + q*1, 0xff)
				if (cur_x == 4 or cur_x == 5) poke(cur_y + q*2, 0xff)
				--if (cur_x == 6)               poke(cur_y + q*3, 0) -- handled above
				if (cur_x >  6)               poke(cur_y + q*4, 0)
				if (cur_x > 0) cur_y += 1
			end
			
		end
	
	end
		
end
	



































:: undo.lua
--[[pod_format="raw",created="2024-03-30 19:03:19",modified="2024-04-28 08:40:20",revision=451]]
--[[

	single undo stack for whole .sfx file

]]

function init_undo()

	undo_stack = create_undo_stack(
		function()
			local mem = userdata("u8",0x40000)
			for i=0,3 do
				set(mem,i*0x10000,peek(0x30000+i*0x10000, 0x10000))
			end
			return {mem,tdat,mode,ci,ct,cp}
		end,
		function(state)
			for i=0,3 do
				poke(0x30000+i*0x10000, get(state[1],i*0x10000,0x10000))
			end
			tdat,mode,ci,ct,cp=state[2],state[3],state[4],state[5],state[6]
		end,		
		-- use raw binary encoding suitable for fixed size memory block (same as gfx)
		--> faster encoding,  smaller patches
		0x11 -- (0x1 binary  0x10 pxu raw)
	)
	
end

function checkpoint()
	undo_stack:checkpoint()
end

function undo()
	undo_stack:undo()
	refresh_gui = true
end

function redo()
	undo_stack:redo()
	refresh_gui = true
end
:: update.lua
--[[pod_format="raw",created="2023-10-22 07:32:11",modified="2024-04-28 08:42:00",revision=8275,stored="2023-36-29 04:36:40"]]
global_t = 0

-- map keyboard letters to pitches

key_pitch="zsxdcvgbhnjmq2w3er5t6y7ui9o0p"

something_is_playing = false

function _update()

	-- find out which channel current instrument is being played on
	ci_channel = -1
	for i=0,31 do
		if (ci_channel == -1 and stat(400+i,1) == ci) then
			ci_channel = i
		end
	end
	
	-- update: something_is_playing
	something_is_playing = false
	for i=0,15 do
		if (stat(400+i,12) != -1) something_is_playing = true -- sfx
		if (stat(400+i,1 ) != -1) something_is_playing = true -- inst
	end
	
	-- or if there is [recently] some global output (e.g. echo or rogue node)
	len = stat(465,0,0xe0000)
	local found_signal
	for i=0,len-7,8 do
		if (peek8(0xe0000+i) != 0) found_signal = true
	end
	if (found_signal) last_found_signal_t = t()
	if (last_found_signal_t and last_found_signal_t > t()-0.1) then
		something_is_playing = true
	end
	

	if (gui) gui:update_all()
	
	if (key"ctrl") then
		-- can't play note when holding control
		
		if (keyp"z") undo()
		if (keyp"y") redo()
	
	elseif (keyp"space") then
		-- inst mode:always kill all audio
		if mode == "instrument" then -- track has own handling
			note() -- kill all channels
		end
	elseif mode == "instrument" then	
		
		local pitch = -1
		--if (keyp("space")) pitch = 48 -- middle c
		if (keyp(",")) pitch = 60 -- to do
		
		for i=1,#key_pitch do
			if key(sub(key_pitch,i,i)) then
				pitch = 35 + i + (coct*12-48)
			end
		end
		
		if (pitch >= 0) then
			note(
				pitch, -- pitch
				ci,    -- inst
				cvol,    -- volume
				0,0,   -- effect, effect_p
				8,     -- channel index -- 8 so that can play with music
				false  -- don't force retrigger (retrigger when pitch/inst changes)		
				)
		else
			-- release
			--if stat(464) == 0 then -- not playing a sfx on any channel
				note(0xff, 0xff, 0xff, 0xff, 0xff, 8)
			--end
		end
		
	end
	

	if (mode == "track" or mode == "pattern") then
		update_track_editor()
	end
	
	-- copy and paste instruments
	if (key"ctrl" and mode == "instrument") then
		if (keyp"c") then
			local ud = userdata("u8",0x200)
			set(ud,0,peek(0x40000+ci*0x200,0x200))
			set_clipboard(pod({
				instrument=ud
			},7,{pod_type="instrument"}))
			notify("copied instrument")
		end
		
		if key("ctrl") and keyp("v") then
			checkpoint()
			local dat = unpod(get_clipboard())
			
			if (dat and type(dat.instrument) == "userdata") then
				poke(0x40000+ci*0x200, get(dat.instrument,0,0x200))
				notify("pasted instrument")
				refresh_gui = true
			else
				notify("could not find instrument data to paste")
			end
		end
	
	end
	
	global_t += 1
	
end









































































:: [eoc]
